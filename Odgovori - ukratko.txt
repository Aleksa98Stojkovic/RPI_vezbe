66. Menadžment zahteva i pisana specifikacija
	- ona tri
	- potiče iz problema i razumevanje potreba
	- model zahteva
	- menadžment zahteva, vidljivost i praćenje, praćenje kroz dizajn, baza podataka
	- 1000 individualni zahtevi
	- opis zahteva(formalni, izvrsni model, prirodni jezik)
	- teziti formalnom i izvrsnom modelu
	- ogranicenja koja unosi izvrsni model

67. ESL domeni - data flow i control flow
	- interesuje nas data path modema, elementi video obrade signala ili generalno obrade signala
	- nema nista bez control flow, ali se zanemaruje, interesantne su transformacije od ulaza do izlaza
	- staticki parametri, SNR
	- performanse algo se procenjuju u MATLABU, C, C++, beskonacni baferi
	- stanja sistema i transformacije
	- DF + CF = funkcionalnost sistema na visokom nivou, razliciti nivoi apstrakcije CF(sa i bez detalja imeplementacije arhitekture, abstrakcije vremena, osnovna stanja i modovi)
	
68. ESL domeni - protokol stek
	- podsistemi ili komunikacioni sistem koji sluze za prenos podataka kroz komunikacione kanale prateci neki skup pravila
	- hijarahijski slojevi, koristis gornji da bi podrzao gornji
	- stratum korisnicki(tok podataka kroz kanal) i kontrolni/upravljacki(kontrolne poruke)
	- embeded softver + hardver
	- fizicki sloj
	- real time zahtevi, modularna arhitektura zbog standarda, message-passing implementacije, limitirana potreba za paralelizmom
	
70. ESL domeni - embeded sistemi
	- Sta su mebeded sistemi
	- Real time zahtevi
	- Inerfejs sa okruzenjem, primer za auto
	- Nefunkcionalni zahtevi(potrosnja, real time zahtevi, resursi, dostupan softver i hardver, ...)

71. Specifikacija koja moze da se izvrsava, objasniti i nabrojati jezike za ovu specifikaciju
	- Idealni svet
	- Ona tri
		1. Automatizacija pracenja zahteva kroz proces dizajna i podsistema
		2. Poboljsanje razumevanja integracije heterogenih sistema
		3. Procesi verifikacije i implementacije se mogu poboljsati
	- Sta je izvrsna specifikacija, bihevialni opis komponenti koji ispoljava funkcije i vremenske karak ciljnog dizajna kada je to pokrenuto kao simulacija
	- Aristotel: verifikacija, u skladu sa sistemski zahtevima i ono za implementaciju
	- implementacijski artifakti
	- Bog inzenjer
	- Od pocetka do kraja, evolucija izvrsne spek
	- UML, XML, MATLAB i SystemC
	
72. Staticka analiza pre particionisanja
	- Kad nemamo izvsnu specifikaciju
	- Monotonost pre preciznosti i objasniti sa primerom
	- Vrste statickih analiza
		1. Function point analysis
		2. Analiza hardverskih ili hardverski dominantnih sistemski specifikacija
		3. ility analize
		4. Rosseta i SysML
	- Za Function point analysis
		- potice iz razvoja softvera
		- dekomponovani funkcionalni model, model podataka i bihevialni model tranzicija stanja
		- objediniti rezultate primenjenih metrika na sva tri modela u tezinskom smislu

73. Analiza pre particionisanja u slucaju koriscenja platformi
	- Reuse, troskovi, vreme razvoja, time to market
	- Neke nove funkcionalnosti se moraju implementirati
	- Vivado + Zynq je platforma
	- Naklonost prema odlukama koje su donete u vezi sa particionisanjem biranjem same platforme
	- disciplina, sve analizirati kao da krecemo od nule

74. Dinamicka anliza pre particionisanja
	- Simulacija
	- Vremensko bazirane karakteristike, arbitracioni algoritmi i planeri
	- racun(profajliranje), komunikacija(pracenje protoka podataka u odredjenim tackama), potrosnja(koliko koja instrukcija trosi energije za datu tehnologiju fabrikacije)
	- host based ececution kad nema odgovarajuci model of computation
	- monotonost pre preciznosti
	
75. Algoritamska analiza pre particionisanja
	- opterecenje izvrsavanja, proracuna, kolicina podataka koja se transportuje, greske, biti, komunikacija
	- float -> fix
	- nije nuzno, ali bolje pre nego kasnije, manje posla posle

76. Koriscenje rezultata analize pre particionisanja
	- za implementaciju i verifikaciju
	- zlatna verifikaciona okruzenja, float i fixed
	- od algo spek do softvera
    - od algo spek do hardvera
	- kosimulacija izmedju sistemske simulacije, rtl simulacije i izvrsavanja softvera na nekom ISS
	- HLS
	- vise prica nego praksa

77. Particionisanje, klasterisanje i apstrakcija, ilustrovati. Objasniti platforme u ovom kontekstu
	- Sta je particionisanje? Deljenje secifikacije na skup potencijalno konkurentnih procesa. Ona cetiri nacina
	- Svaka particija se moze opisati na ona cetiri nacina, manje ili vise apstraktan resurs
	- Nezavisnost i interfejsi i verifikacija
	- Optimizacije
	- podeli pa vladaj
	- apstrakcija i grupisanje
	- platforma je klaster, sakriva detalje razlicitih vrsta mogucih implementacija
	- aplikacija i visi nivo apstrakcije
	- deljenje troskova dizajna i fabrikacije
	- mapiranje
	- funkcionalni objekti i komunikacione linije na elemente platforme i komunikacione puteve
	- funkcije na arhitekturalne elemente, FFT -> DSP

78. Koraci pri particionisnju
	- Identifikacija funkcionalnih komponenti
	- Definisanje ciljane arhitekture, ogranicenja
	- Mapiranje funkcionalnih jedinica na arhitekturalne jedinice, ogranicenja
	- Detaljno definisanje interfejsa medju particijama, komunikacija unutra, sinteza ili manuelno
	- sve se moze automatizovati, ali sve je teze kako se ide gore

79. Funkcionalna dekompozicija pri particionisanju
	- Dva zahteva, funkcionalna reprezentacija sistema, bez implementacionih detalja, odredjeni nivo paralelizma na aplikacionom nivou da bi se iskoristila konkurentnost
	- Dva mehanizma, jezici za funkcionalnu konkurentnu izvrsnu specifikaciju, alati za automatsko izvlacenje paralelizma iz sekvencijalnog opisa(neuspesno)

80. Opis arhitekture pri particionisanju
	- Sta je arhitektura? kolekcija komponenti koje implementiraju neko ponasanje
	- jedan na jedan korespodencija
	- klase
	- apstraktni sematik
	- nije jedan na jedan u slozenim slucajevima
	- mrezni protokoli, skupovi instrukcija, arbitrazne politike
	- softverska arhitektura(organizacija taskova, slojevi, RTOS)
	- slozena specifikacija + ponovno koriscenje = platforma

81. Platforme pri particionisanju
	- Zasto platforme, time to market je BOG
	- razlicite implementacije slicnih specifikacija ili su slicni zahtevi
	- mali broj dobrih resenja
	- dizajnerska disciplina

82. Dodela pri particionisanju, navesti strategije i objasniti ih
	- Mapiranje se moze uraditi na dva nacina
	- sukcesivno prifinjenje - obratiti paznju na komunikaciju i racun
	- eksplicitno mapiranje - alati koji daju analizirane profinjene modele i daju uputsva za sintezu
	- A = Funkcionalni model bez vremena = specifikacioni model, model B = dodajemo info o arhitekturi i tajming za funkcije = skup komponenti
	- C = dodajemo prvi info za komunikaciju i vreme u kmunikaciji, to radimo odabirmo arbitra = model sa arbitrazom na magistrali
	- D = model proracuna tacan u ciklus, E = bihevijalni model sa funkcionalnom magistralom, F = RTL model
	
83. Hardversko particionisanje
	- Svodi se na konfiguraciju platforme
	- Softver je kopleksniji, opravdano je cenom alata i resenja bagova, ali ne i njihovim dijagnostikovanjem i razotkrivanjem
	- verifikacija je sada nuzna

84. Softversko particionisanje
	- Samo kriticni delovi vezani za vreme i potrosnju idu u hardver
	- Sve vise funkcija trci na nekim procesorima
	- embeded procesori
	- OS i taskovi
	- OS apstrahuje hardver
	- losa softverska arhitektura -> lose performanse sistema
	- dobra softverska arhitektura omogucava hardver dizajnerima da iscrpno istraze mogucnosti platforme

85. Softverko particionisanje na multiprocesorima i zadacima
	- Vise procesora istih ili razlicitih
	- Konkurentnost
	- Sinhronizacija i komunikacija taskova na razlicitim procesorima, namesnki komunikacioni mehanizmi
	- Podela softvera na jednom procesoru
	- Planer, promena konteksta i komunikacija

86. Softversko particionisanje u operativnim sistemima
	- Potreban je OS
	- Sta je OS
	- Alokacija memorije, implementacija komunikacije, zastita taskova
	- Uzeti u obzir OS pri softverskom particionisanju
	- Direktno mapiranje
	- Promene u OS vode do novog mapiranja
	