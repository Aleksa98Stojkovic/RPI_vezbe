66. Menadžment zahteva i pisana specifikacija
	- ona tri
	- potiče iz problema i razumevanje potreba
	- model zahteva
	- menadžment zahteva, vidljivost i praćenje, praćenje kroz dizajn, baza podataka
	- 1000 individualni zahtevi
	- opis zahteva(formalni, izvrsni model, prirodni jezik)
	- teziti formalnom i izvrsnom modelu
	- ogranicenja koja unosi izvrsni model

67. ESL domeni - data flow i control flow
	- interesuje nas data path modema, elementi video obrade signala ili generalno obrade signala
	- nema nista bez control flow, ali se zanemaruje, interesantne su transformacije od ulaza do izlaza
	- staticki parametri, SNR
	- performanse algo se procenjuju u MATLABU, C, C++, beskonacni baferi
	- stanja sistema i transformacije
	- DF + CF = funkcionalnost sistema na visokom nivou, razliciti nivoi apstrakcije CF(sa i bez detalja imeplementacije arhitekture, abstrakcije vremena, osnovna stanja i modovi)
	
68. ESL domeni - protokol stek
	- podsistemi ili komunikacioni sistem koji sluze za prenos podataka kroz komunikacione kanale prateci neki skup pravila
	- hijarahijski slojevi, koristis gornji da bi podrzao gornji
	- stratum korisnicki(tok podataka kroz kanal) i kontrolni/upravljacki(kontrolne poruke)
	- embeded softver + hardver
	- fizicki sloj
	- real time zahtevi, modularna arhitektura zbog standarda, message-passing implementacije, limitirana potreba za paralelizmom
	
70. ESL domeni - embeded sistemi
	- Sta su mebeded sistemi
	- Real time zahtevi
	- Inerfejs sa okruzenjem, primer za auto
	- Nefunkcionalni zahtevi(potrosnja, real time zahtevi, resursi, dostupan softver i hardver, ...)

71. Specifikacija koja moze da se izvrsava, objasniti i nabrojati jezike za ovu specifikaciju
	- Idealni svet
	- Ona tri
		1. Automatizacija pracenja zahteva kroz proces dizajna i podsistema
		2. Poboljsanje razumevanja integracije heterogenih sistema
		3. Procesi verifikacije i implementacije se mogu poboljsati
	- Sta je izvrsna specifikacija, bihevialni opis komponenti koji ispoljava funkcije i vremenske karak ciljnog dizajna kada je to pokrenuto kao simulacija
	- Aristotel: verifikacija, u skladu sa sistemski zahtevima i ono za implementaciju
	- implementacijski artifakti
	- Bog inzenjer
	- Od pocetka do kraja, evolucija izvrsne spek
	- UML, XML, MATLAB i SystemC
	
72. Staticka analiza pre particionisanja
	- Kad nemamo izvsnu specifikaciju
	- Monotonost pre preciznosti i objasniti sa primerom
	- Vrste statickih analiza
		1. Function point analysis
		2. Analiza hardverskih ili hardverski dominantnih sistemski specifikacija
		3. ility analize
		4. Rosseta i SysML
	- Za Function point analysis
		- potice iz razvoja softvera
		- dekomponovani funkcionalni model, model podataka i bihevialni model tranzicija stanja
		- objediniti rezultate primenjenih metrika na sva tri modela u tezinskom smislu

73. Analiza pre particionisanja u slucaju koriscenja platformi
	- Reuse, troskovi, vreme razvoja, time to market
	- Neke nove funkcionalnosti se moraju implementirati
	- Vivado + Zynq je platforma
	- Naklonost prema odlukama koje su donete u vezi sa particionisanjem biranjem same platforme
	- disciplina, sve analizirati kao da krecemo od nule

74. Dinamicka anliza pre particionisanja
	- Simulacija
	- Vremensko bazirane karakteristike, arbitracioni algoritmi i planeri
	- racun(profajliranje), komunikacija(pracenje protoka podataka u odredjenim tackama), potrosnja(koliko koja instrukcija trosi energije za datu tehnologiju fabrikacije)
	- host based ececution kad nema odgovarajuci model of computation
	- monotonost pre preciznosti
	
75. Algoritamska analiza pre particionisanja
	- opterecenje izvrsavanja, proracuna, kolicina podataka koja se transportuje, greske, biti, komunikacija
	- float -> fix
	- nije nuzno, ali bolje pre nego kasnije, manje posla posle

76. Koriscenje rezultata analize pre particionisanja
	- za implementaciju i verifikaciju
	- zlatna verifikaciona okruzenja, float i fixed
	- od algo spek do softvera
    - od algo spek do hardvera
	- kosimulacija izmedju sistemske simulacije, rtl simulacije i izvrsavanja softvera na nekom ISS
	- HLS
	- vise prica nego praksa

77. Particionisanje, klasterisanje i apstrakcija, ilustrovati. Objasniti platforme u ovom kontekstu
	- Sta je particionisanje? Deljenje secifikacije na skup potencijalno konkurentnih procesa. Ona cetiri nacina
	- Svaka particija se moze opisati na ona cetiri nacina, manje ili vise apstraktan resurs
	- Nezavisnost i interfejsi i verifikacija
	- Optimizacije
	- podeli pa vladaj
	- apstrakcija i grupisanje
	- platforma je klaster, sakriva detalje razlicitih vrsta mogucih implementacija
	- aplikacija i visi nivo apstrakcije
	- deljenje troskova dizajna i fabrikacije
	- mapiranje
	- funkcionalni objekti i komunikacione linije na elemente platforme i komunikacione puteve
	- funkcije na arhitekturalne elemente, FFT -> DSP

78. Koraci pri particionisnju
	- Identifikacija funkcionalnih komponenti
	- Definisanje ciljane arhitekture, ogranicenja
	- Mapiranje funkcionalnih jedinica na arhitekturalne jedinice, ogranicenja
	- Detaljno definisanje interfejsa medju particijama, komunikacija unutra, sinteza ili manuelno
	- sve se moze automatizovati, ali sve je teze kako se ide gore

79. Funkcionalna dekompozicija pri particionisanju
	- Dva zahteva, funkcionalna reprezentacija sistema, bez implementacionih detalja, odredjeni nivo paralelizma na aplikacionom nivou da bi se iskoristila konkurentnost
	- Dva mehanizma, jezici za funkcionalnu konkurentnu izvrsnu specifikaciju, alati za automatsko izvlacenje paralelizma iz sekvencijalnog opisa(neuspesno)

80. Opis arhitekture pri particionisanju
	- Sta je arhitektura? kolekcija komponenti koje implementiraju neko ponasanje
	- jedan na jedan korespodencija
	- klase
	- apstraktni sematik
	- nije jedan na jedan u slozenim slucajevima
	- mrezni protokoli, skupovi instrukcija, arbitrazne politike
	- softverska arhitektura(organizacija taskova, slojevi, RTOS)
	- slozena specifikacija + ponovno koriscenje = platforma

81. Platforme pri particionisanju
	- Zasto platforme, time to market je BOG
	- razlicite implementacije slicnih specifikacija ili su slicni zahtevi
	- mali broj dobrih resenja
	- dizajnerska disciplina

82. Dodela pri particionisanju, navesti strategije i objasniti ih
	- Mapiranje se moze uraditi na dva nacina
	- sukcesivno prifinjenje - obratiti paznju na komunikaciju i racun
	- eksplicitno mapiranje - alati koji daju analizirane profinjene modele i daju uputsva za sintezu
	- A = Funkcionalni model bez vremena = specifikacioni model, model B = dodajemo info o arhitekturi i tajming za funkcije = skup komponenti
	- C = dodajemo prvi info za komunikaciju i vreme u kmunikaciji, to radimo odabirmo arbitra = model sa arbitrazom na magistrali
	- D = model proracuna tacan u ciklus, E = bihevijalni model sa funkcionalnom magistralom, F = RTL model
	
83. Hardversko particionisanje
	- Svodi se na konfiguraciju platforme
	- Softver je kopleksniji, opravdano je cenom alata i resenja bagova, ali ne i njihovim dijagnostikovanjem i razotkrivanjem
	- verifikacija je sada nuzna

84. Softversko particionisanje
	- Samo kriticni delovi vezani za vreme i potrosnju idu u hardver
	- Sve vise funkcija trci na nekim procesorima
	- embeded procesori
	- OS i taskovi
	- OS apstrahuje hardver
	- losa softverska arhitektura -> lose performanse sistema
	- dobra softverska arhitektura omogucava hardver dizajnerima da iscrpno istraze mogucnosti platforme

85. Softverko particionisanje na multiprocesorima i zadacima
	- Vise procesora istih ili razlicitih
	- Konkurentnost
	- Sinhronizacija i komunikacija taskova na razlicitim procesorima, namesnki komunikacioni mehanizmi
	- Podela softvera na jednom procesoru
	- Planer, promena konteksta i komunikacija

86. Softversko particionisanje u operativnim sistemima
	- Potreban je OS
	- Sta je OS
	- Alokacija memorije, implementacija komunikacije, zastita taskova
	- Uzeti u obzir OS pri softverskom particionisanju
	- Direktno mapiranje
	- Promene u OS vode do novog mapiranja
	
87. Odgovornost interfejsa i odrzavanje modela nakon particionisanja. Ilustrovati i ukratko objasniti.
	- Mogu se otkriti problemi, recimo, pri implementaciji, pa se treba vratiti nazad
	- Margina
	- Odgovornost interfejsa ostaje onom ko ga kreira
	- odrzavanje, azurirati prethodne modele

88. Objasniti sta je hardversko i softversko modelovanje i komodelovanje i nasvesti vrste
	- modeli HW i SW treba da saradjuju
	- moraju postojati kompatibilni interfejsi
	- Jedinstven model, filtriranje i transliranje(emulator), posebni(separata) modeli(prototip)

89. Hardvesko - softversko modelovanje - jedinstven model
	- nivo detalja ne mora biti velik sve dok su transakcije na interfejsnima dovoljno precizne
	- brz model na domacinu + lak debag
	- nije jasno sta je HW i sta he SW, kao i koliko detalja
	- nadleznost ostaje sistemskom inzenjeru
	- koristi se u fazi pre particionisanja, ali moze biti od koristi i posle
	- verifikacija softvera

90. Hardvesko - softversko modelovanje - filtriranje i transliranje
	- jasno definisan SW model
	- promenljiva u deljenoj memoriji
	- lakse se deli odgovornost, specificiranje aktivnosti je u nadleznosti SW inzenejera iako filter komponentu implementira hardverski tim
	- za SW na niskom nivou ili kad su poznati registri
	- poznata SW komponenta, ali HW platforma je promenljiva

91. Hardvesko - softversko modelovanje - posebni modeli
	- moze da se koristi za modelovanje na razlicitim nivoima apstrakcije(RTL model procesora, aproksimativni u ciklus modelu, tacni u ciklus modeli, modeli skupa instrukcija)
	- kada se koristi za najnizi nivo apstrakcije onda model moze biti spor zbog velikog broja detalja
	- Jasna podela olaksava dodelu odgovornosti, sistem dizajn tim je zaduzen za interfejse. Ovaj stil verifikuje specifikaciju
	- Slicno kao i filtriranje, za jedostavnije prelaze sa jednog nivoa apstrakcije na drugi treba korisititi komponente za translaciju transakcija

92. Komponente koje se koriste nakon particionisanja. Ilustrovati an primeru
	-  Da bi prelazi apstraktni model -> particionisani model bio jednostavan treba pisati modele istim stilom
	- Mix komponenti model pre i posle particionisanja -> bolje pretrazivanje prostora dizajna i otkrivanje defekata u modelima
	- Odvajanje funkcije od komunikacije
	- Profinjavanje interfejsa ili postojanje komponenti za translaciju
	- Primer

93. Dinamicka i staticka analiza nakon particionisanja. Kratko objasniti i nasvesti vrste analize
	- Sada je moguce uraditi prve znacajne analize, jer imamo particionisani model, pa mozemo videti da li treba nesto optimizovati
	- dinamicka, simulacija
	- staticka, formalne analize
	- hibridna je mix, staticka analiza podataka dobijenih dinamickim analizama, tj simulacijom, model dobije statickom analizom se dinamicki analizira
	- Vrste analiza
		1. Funkcionalna
		2. Performanse
		3. Analiza interfejsa
		4. Snage
		5. Povrsine
		6. Cene
		7. Analiza mogucnosti pronalazenja greski

94. Funkcionalna analiza nakon particionisanja
	- Vise nivoa korektnosti, imamo model blizak implementaciji
	- FIFO i keš
	- Skupljanje info o akumuliranim kasnjenjima i velicini redova cekanja i komponenata koji stvaraju ta uska grla
	- Moguca optimizacija moze dovesti do ponovnog particionisanja

95. Analiza performansi nakon particionisanja
	- Imamo particionisan model i neku sliku konkurentnosti i podele resursa
	- mogu se izvrsiti preciznije analize
	- koristimo realne podatke, jer funkcionalnost i tajming zavise od podataka
	- dinamicki generisemo podatke, a vrsimo staticke analize dobijenih povratnih info
	- usput proveravamo dok traje simulacija

96. Analiza interfejsa nakon particionisanja
	- na ovom nivou imamo apstraktne interfejse
	- dve klase, standardne magistrale i nase definisane magistrale
	- standardne ne predstavljaju problem, jer su dobro testirane
	- nove treba proveriti da li mogu da ispune zeljeni protok
	- ispravljanje u RTL-u je kasno
	- verifikovati nove interfejs komponente do najnizeg nivou apstrakcije

97. Analiza snage nakon particionisanja
	- Imamo model posle particionisanja, pratimo protok i aktivnost podataka
	- na grafikonu blezimo aktivnost dvake komponente i to povezujemo sa potrosnjom
	- ovo nije narocito precizno, ali daje neku siru sliku o potrosnji
	- gomila simulacija i iskustva
	- ukljuciti i ivicne slucajeve

98. Analiza povrsine nakon particionisanja
	- Imamo model po 500. put
	- Mozemo proceniti kompleksnot svake komponente koristeci standardne metrike
	- Ovo moze biti neprecizno bez prethodnih podataka
	- kada koristimo nove metrike, onda je dobro da uzmemo podatke iz analiza sa prethodnih projekata
	- treba analizirati uspehe i neuspehe projekata nakon sto je on zavrsen da se ne bi krenulo od nule svaki put

99. Analiza cene nakon particionisanja
	- Koriste se rezultati raznih analiza
	- Cena zavisi od toga da li se koristi platforma, koja tehnologija, koje komponente, kao i od slozenosti novih komponenti
	- Procena cene je neprecizna ako nemamo podatke iz predjasnjih projekata
	- Korstimo metrike za procenu slozenosti softvera

100. Analiza mogucosti pronalazenja greski nakon particionisanja
	- Ponasanje fabrikovanog cipa moze se osmatrati preko pinova
	- svi bagovi mogu jedino tako da se uoce
	- obicno je potrebna posebna dodatna logika koja signalizira odredjene situacije na pinovima koje se desavaju u cipu
	- cesto se o time pocne baviti tek pri kraju implementacije, sto je kasno
	- DFT treba poceti ranije u procesu razvoja