7. Sta je model i znacaj
	- Model je obrazac, plan, reprezentacija ili opis nekog principa funkcionisanja objekta, sistema ili koncepta
	- Omogucava da se ispituju stvari koje jos ne postoje i kasnije da profinjujemo model
	- Najjednostavniji model koji daje tacne odgovore
	- EDA industrija, tranzistori, ograniciti se na broj modela
	- Vise detalja = precizniji rezultati, ali sporiji model
	- Manje detalja = suprotno od vise detalja

8. Vrste modela
	- Konceptualni model = istice vazne veze izmedju procesa, zivi u domenu problema, Petri mreze, process flow graph, grafovi dogadjaja, UML
	- Fizicki modeli = kao na arhitekturi, mogu da se naprvae, uoce i manipulisu. Dele neke karakteristike sa realnim sistemom
	- Matematicki model = set jednacina, numericki i analiticki model. Statisticki model = modeluje varijanse i mogu se meriti varijanse i srednje vrednosti
	- Vizualni modeli = vizualizuju rad sistema, imaju vizualne elemente u svom izlazu
	- Logicki modeli = imaju neke aspekte strukture ili forme, arhitekturalni modeli, TLM i svi modeli sa nekim aspektom vremena

9. Modeli izracunavanja
	- Model izracunljivosti obuhvata fundamentalne aspekte mogucnosti sistema da resava probleme
	- Asprahuje mnoge detalje(vreme) kako bismo imali brzi i precizniji model
	- Ne mozemo imati jedan jedinstven model izracunavanja u ESL toku razvoja sistema
	- SW model = Fon Nojmanova arhitektura, HW = model baziran na diskretni dogadjajima
	- Jezik omogucava mapiranje mogucnosti modela izracunavanja na nesto sto se moze opisati i sa cim se moze komunicirati
	- jezik je sintaksa, a model izracunljivosti semantika
	- Ono za C i pre toga, sta god to znacilo
	- SW i HW ne mogu imati isti model izracunljivosti
	
10. Uproscavanje, navesti vrste i ukratko objasniti
	- Eliminacija, apstrakcija i struktura(modeli nam omogucavaju da pojednostavimo problem)
	- u SW najnizi nivo apstrakcije je instrukcija. Apstraktniji nivo je C jezik
	- U HW apstrakcije se vezuju za podatke i vreme
	- Hijararhija je potrebna da bi alati za sintezu preziveli. Hijararhija nam omogucava da grupisemo vise komponenti koje cine neku logicku celini, sto se moze i duplicirati.
	- Hijararhija pojednostavljuje dizaj, jer ga deli na manje probleme

11. Modeli i jezici
	- Jezici za modelovanje su vestacki jezici koji izrazavaju neke koncepte, tako da ti nezavisni alati mogu da interpretiraju taj opis za potrebe, npr simulacije ili sinteze
	- Jezici su bazirani na tri skupa koncepta: semantika, apstraktna i konkretna sintaksa
	- Semantiku cine pravila koja trebaju da se postuju u tom jeziku
	- Apstraktna sintaksa opisuje kako su komponente povezane strukturalno, ali ne govori nista o semantici tih veza
	- Imperativni jezici = vrse naredbe odredjenim redosledom
	- Deklarativni jezici = govore sta treba da se uradi, ali ne i kako(PSL i SVA)
	- Funkcionalni jezici = definisu funkciju sistema, imperativni i deklarativni jezici spadaju u ovu grupu
	- Dinamicki jezici i modeli se dele na arhitekuralni(SystemC) i algoritamski(MATLAB(matematicki jezici), Simulink(Data flow jezik)) pristup modelovanju
	- Nefunkcionalni jezici = zadaju ogranicenja koja sistem treba da ispuni(SDC za ogranicenja u Vivadu)
	- Meta modeli = IP-XACT jezik koji govori koji su interfejsi i kako su komponente te povezane, ali ne daje druge detalje
	
12. Takosnomija ESL-a, objasniti sta je, navesti sve ose
	- Taksonomija predstavlja karakterizaciju objekata ili koncepata baziranih na njihovim odnosima sa ciljem klasifikovanja
	- Primer je periodni sistem elementata gde su elementi klasifikovani na osnovu odredjenih osobina 
	- Taksonomija se moze izraziti pomocu hijararhijskog grafa ili tabele atributa, gde atributi identifikuju odredjeni element razlicitosti
	- Vremenska osa, osa podataka, osa konkurentnosti, osa kumunikacije, osa konfigurabilnosti
	
13. Vremnska osa ESL taksonomije
	- Parcijalno rasporedjeni dogadjaji = ne znamo tacno kada pocinje i zavrsava, ali znamo u odnosu na druge dogadjaje
	- Sistemski dogadjaji = dogadjaji na nivou sistema(interrupt)
	- Token ciklusi = za dataflow modele, podaci dostizu u pravilo rasporedjenim trenucima
	- Intrukcioni ciklusi = ne uzimaju se u obzir stanja cekanja i uticaj hardvera na izvrsavanje softvera. Pristupi memoriji su cisto virtualni
	- Aproksimativni u ciklus = postoji pojam vremena za transakcije na magistralama i za pristupe memoriji, ali nije precizan previse
	- Tacno u ciklus = znamo sve svaki ciklus
	- Precizno na nivou kasnjenja logickih kapija = znamo vremena i unutar jedne periode

14. Osa podataka ESL taksonomije
	- Token = podatak se krece kroz sistem, ali nema nikakvih detalja o njemu
	- Property = podatak je imenovan, ali nije odredjeno kako se reprezentuje
	- Value = definisan je tip podataka i nivo preciznosti koji ce se korisiti u hardveru
	- Format = tacan format podatak koji ce se koristiti u procesoru(fp ili fxp, endian)
	- Bit logical = poznato je mapiranje vrednosti na hardverski elemenat koji ga skladisti
	
15. Osa konkurentnosti ESL metodologije
	- Hocemo da vidimo koje obrade mogu da se vrse simultano
	- Ne mora sav paralelizam da se iskoristi, jer veca konkurentnsot znaci i slozeniji sistem i komplikovanija verifikacija
	- Sekvencijalno = nema paralelizma u implementaciji, C kod
	- Multiaplikacijska = vise aplikacija se izvrsava u paraleli, a razmenjuju podatke preko fajl sistema
	- Paralelno = jedna aplikacija je razbijena na vise zadataka, pri cemu ti procesi komuniciraju pomocu nekih poruka(ne moze deljena memorija)
	- Multinitno = isto kao paralelno, ali se koristi deljenja memorija
	- Protocna obrada = imamo faze u obradi koje mogu istovremeno da se izvrsavaju
	- Na nivou signala = vise kombinacionih puteva se izvrsava u paraleli

16. Osa komunikacije ESL metodologije
	- Komunikacija je potrebna kada imamo vise elemenata za obradu
	- Od tacke do tacke = najcesce u HW, ima direktana veza sto daje neprekidan protok podataka
	- Baferovana = osnovni vid upravljane komunikacije, povezuju se procesi koji mogu imati razlicite brzine obrade podataka
	- Koprocesor = proizvodjac - potrosac, procesor je vlasnik info, a koprocesor izvrsava neku specificnu funkciju
	- Memorija = moramo da imamo vise portova, po jedan za svaki proces u komunikaciji, procesi moraju da imaju svoj interfejs, a ne da pristupaju preko neke magistrale
	- Magistrale(brze) = NoC i sve magistrale koje su vezane za procesor, koristi se vise magitrala, pa je potrebno da imamo mostove izmedju njih
	- Magistrale(sporije) = na vecu razdaljinu i postoji slozeniji protokol, pa shodno tome i vece kasnjenje(USB i PCI)
	- Nema komunikacije = kada su procesi nezavisni u potpunosti

17. Odnos osa konkurentnosti i komunikacije ESL taksonomije

				       *
				     *
	.		     * * *
	.	     * * * *
	.	     * * * *
signal	   * 
		point2point ...
		
18. Osa konkurentnosti ESL metodologije	
	- Fiksno = nemamo pristup unutrasnjosti dizajna i ne mogu se izvrsiti nikakve promene, ovo se moze uraditi na svim nivoima apstrakcije(npr dat nam je kompajliran objektni kod)
	- Dizajn = kada imamo pristup izvornim kodovima, onda je dizaj konfigurabilan. To je normalno u procesu dizajna HW i SW komponenti
	- Konfigurabilni = primer za IP, ne moze se dodati nista novo bez redizajna
	- Programabilnost = za FPGA, uredjaje konfigurisemo prilikom pokretanja, ali zbog male brzine tokom porgramiranja, ovo se ne smatra dinamicki rekonfigurabilnim uredjajima
	- Dinamicki rekonfigurablno = neke FPGA ploce, moze se vrsiti reprogramiranje tokom izvrsavanja operacija
	- Ova osa je ortogonalna osama konkrentnosti i komunikacije
	
19. Navesti sve ose ESL taksonomije i tacke na njima
	- Ide od najvece rezolucije
	- Vremenska osa: kasnjenje na nivou kapija
	- Osa podataka = bit logical
	- Osa konkurentnosti = signal
	- Osa komunikacije = od tacke do tacke
	- Osa konfigurabilnosti = fiksirano

20. Ilustrovati ESL taksonomiju na primeru funkcionalnog modela
	- Funkcionalni model opisuje ponasanje sistema, a da ga ne implementira
	- Nema nikakav aspekt vremena, ali ima sve ESL atribute
	- Ima sve tacke na svim osama, ali nema nista iz tajminga

21. Ilustrovati ESL taksonomiju na primeru HDL opisa
	- Vremenska osa = Nema parcijalno rasporedjene i sistemske dogadjaje
	- Osa podataka = Nema token
	- Konkuretnost = Ima signale i protocnu obradu
	- Komunikacija = Ima od tacke do tacke i baferovanu komunikaciju
	- Konfigurabilonst = Ima sve
	
22. Ilustrovati ESL taksonomiju na primeru FPGA resenja
	- Vremenska osa = Nema parcijalno rasporedjene i sistemske dogadjaje
	- Osa podataka = Nema token
	- Konkuretnost = Ima signal i protocnu obradu
	- Komunikacija = Ima baferovanu komunikaciju i koprocesor
	- Konfigurabilonst = Nema fiksno i dizajn	

23. Ilustrovati ESL taksonomiju na primeru uopstenog C resenja
	- Vremenska osa = Nema kasnjenje na nivou kapija, aproksimativno i tacno u ciklus
	- Osa podataka = Nema bit logical i format
	- Konkuretnost = Ima sekvencijalno, nema konkurentnost(ali osa je precrtana)
	- Komunikacija = Nema nista
	- Konfigurabilonst = Ima dizajn i fiksno

24. Ilustrovati ESL taksonomiju na primeru SystemC resenja
	- Vremenska osa = Nema kasnjenje na nivou kapija
	- Osa podataka = Ima sve
	- Konkuretnost = Nema sekvencijalno i multiaplikacijsko
	- Komunikacija = Ima od tacke do tacke, baferovanu i memorijsku komunikaciju
	- Konfigurabilonst = Ima fiksno i dizajn
	
25. Hardverska konfiguracija i kontrola softvera - softverska perspektiva, API
	- Softver moze da radi sa HW: resetovanje, konfigurisanje, citanje i upisivanje podataka u memorijske elemente i dobijanje statusa HW
	- Sta je SAHE, SAHE se implementira pomocu memorija, registra i bit polja
	- SW vidi HW kao deo adresnog prostora
	- Optimizovati transakcije
	- LAU
	- Pakovanje SAHE-a ili SAHE u zaseban registar
	- Za citanje moze da SW cuva kopiju registra ili da vrsi RMW operacije(mogucnost za nedeterministicke greske)
	- Kad je SAHE prevelk, onda mora na vise registara
	- API upravlja efikasno sa SAHE-evima na najnizem nivou
	- API na visem nivou se dobija od API-ja na nizem
	- Postoji mogucnost da se napravi API nezavisan od HW

26. Hardverska konfiguracija i kontrola softvera - hardverska perspektiva, prekidi
	- Hardver vidi sistem kao mrezu komponenti
	- Transakcije se mapiraju na promene vrednosti napona na pojedinim zicama u skladu sa specifikacijom
	- Prekidi su za SW asinhroni dogadjaji
	- HW obavestava SW o dogadjajima pomocu prekida
	- ISR
	- Prioriteti
	- Kasnjenje prekida

27. Protokoli na magistralama i translacija protokola
	- Protokol = promene vrednosti na zicama na osnovu skupa pravila
	- Specifikacija definise pravila protokola(adresiranje, podatke, vreme, klokovanje, rukovanje)
	- AXI, AMBA, USB, UART, I2C, ...
	- Master i Slave
	- Burst, indikacija za kraj write burst, klokovanje, interleaved and out of order transakcije, provera gresaka, 
	  pristupi pojedinacnim bajtovima, arbitraza kada imamo vise mastera, kontrola za rukovanje i ubacivanje stanja za cekanje
	- Potrebno vise protokola, a tada i translacija medju njima
	- Dodatne transformacije : resinhronizacija kada se prelazi u drugi takt domen, promena naponskog nivoa, protocna obrada
	- Zelimo manji broj protkola koji postoje izmedju izvora i destinacije, jer to smanjuje kasnjenje
	
28. Registri i bitska polja
	- Registri su memorijski mapirani, najcesce su najmanje jedinice HW/SW interfejsa
	- Odnos registara i SAHE-a i LAU-a
	- Registri mogu biti read-only ili read-write
	- Bitska polja i njihov odnos sa SAHE
	- Osobine bitskih polja : sirina, ofset, tip(citanje, pisanje), reset vrednost
	- Opis transakcije i burst
	- Sporedni efekti prilikom pisanja i citanja registra(R2C, W1toC, W0toC, ...)
	- Uslozavanje verifikacije
	- Bezbroj mogucnosti za implementaciju tih registara -> novi ivicni slucajevi
	 (citanje i pisanje se radi na razlicitim adresama, citanje registra je kao FIFO(stalno dobijamo drugu vrednost), jedan registar se moze mapirati na vise adresa)
	
29. Tok projektovanja za HW/SW interjes - uopsteno, dokumentacija, IP-XACT, SystemRDL
	- Sve pocinje od pisane specifikacije HW/SW interfejsa
	- Vodopad metodologija = pisana dokumentacija -> RTL dizajner pravi RTL testove -> Sistem dizajner pravi sistemske testove -> Softver tim pise firmware biblioteke i testove
	- Opisati nasu tabelu za registre, jer tako se profesionalno pise dokumentacija za taj interfejs
	- IP-XACt je standard u XML koji se moze koristiti za opisivanje memorijsko mapiranih registara
	- SystemRDL je jezik koji sluzi za opisivanje registara

30. HW/SW interfejs u kontekstu IP dizajna, IP verifikacije kao i verifikacije na nivou cipa
	- IP treba da implementira logiku za dekodovanje i modeluje registre
	- Verifikacija interfejsa na nivou IP-ja ispituje, simulacijom(UVM), pisanja i citanja registara
	- Treba proveriti: reset vrednosti, pristup svim validnim bitima, da li ima nezeljenih sporednih efekata kada se pristupa nevalidnim adresama,
	  da li se sporedni efekti ponasaju kako su specificirani
	- I na nivou cipa treba obratiti paznju na detalje HW/SW interfejsa
	- Problemi: Implementacija i specifikacija se ne podudaraju, mirorovanje registara usled preuske adresne magistrale, 
	  greske prilikom dekodovanja i preklapanje adresnih prostora usled loseg memorijskog mapiranja 
	- Testovi se rade u HVL-u(read i write) ili se kompajlira C program, pa se binarni fajl ucita u model embeded procesora
	- Registri moraju biti modelovani iz perspektive procesora da bismo imali veliku pokrivenost
	- Simulacija RTL modela je dugotrajna, treba razmotriti i formalnu verifikaciju

31. Razvoj i verifikacija firmvera
	- Firmver = najnizi sloj softvera koji komunicira sa registrima, API
	- efikasno citanje i pisanje u registre
	- beskonacno mnogo nacina da se implementira
	- Sa i bez makroa
	- C++ funkcije sa makroima predstavlja dobar nacin za pisanje firmvera
	- Verifikacija se vrsi pomocu HW modela(od RTL do virualne platforme, zavisi koji su kriterijumi za SW)

32. Tradicionalni tok razvoja i alati za HW/SW interfejs
	- Tradicionalno to je bilo preko pisanog dokumenta(kao sto smo ranije videli i radili na projektu)
	- Svaki tim interpretira - translira - daje povratnu informaciju vezano za sepcifikaciju interfejsa(ITF)
	- Ovo uvodi mogucnost za greske u interpretaciji, sinhronizaciji i translaciji
	- Imaju moderni alati koji su automatizovani

33. Alati za upravljanje registrima
	- Automatizuju proces generisanja svih potrebnih info za HW/SW interfejs
	- Interfejs je opisan u nekom jeziku i to predstavlja izvrsnu specifikaciju
	- Alati od tog opisa generisu dokumentaciju, RTL model i testove, sistemski virtualni model i tetsove, firmver biblioteke i testove
	- imamo centralizovani model koji je osnova za sve oblasti razvoja, pa nema gresaka, jer nema tumacenja
	- mozemo dobiti i IP-XACT opis interfejsa i regresije
	- Imaju komercijalni alati, a nekada timovi sami razvijaju alate

34. Motivacija za ESL metodologiju
	- Tradicionalni nacini projektovanje podrazumeva vodopad metodu(Platforma -> HW -> SW -> prototip, nema nazad nakon jednog koraka)
	- Sistemi se usloznjavaju, ne moze sve u SW zbog potrosnje i performansi, ne moze samo da se poveca frekvencija CPU-a, jer to skodi potrosnji
	- Namenski hardver trazi dosta vremena, veci nivo paralelizma oduzava razvoj(slozenija verifikacija)
	- Imamo multiprocesorske sisteme koji zahtevaju dosta vremen i zaseban softver
	- RTOS je vezan za HW
	- Statistike
	- Sta je prednost ESL-a(mozemo se vracati an prethodne korake, razvoj SW i HW se moze paralelizovati, takodje i verif ide usput za svaki nivo apstrakcije)

35. Potencijalne vrednosti sistema za VSP-a
	1) Lakse pretrazivanje prostora dizajna i donosenje arhitekturalnih odluka(brze nego u RTL-u)
	2) Relativno precizna procena performansi(do 15% greske)
	3) Analitcko HW/SW particionisanje, na osnovu metrika cije vrednosti dobijamo simulacijom, mozemo brzo izvrsiti novo particionisanje dok ne dobijemo zadovoljavajuce performanse
	4) Razvoj SW moze da pocne mnogo ranije, jer imamo programski pogled na HW unutar VSP, uz pomoc nekih alata to se lako radi
	5) Veci nivo determinizma na sistemskom nivou = mozemo da reprodukujemo bilo koje ponasanje
	6) Brze izvrsavanje hardverskog modela i njegove verifikacije, umesto na RTL nivou
	7) Brze izvrsavanje i koverifikacija SW i HW zajedno
	8) Besplatni test benc na sistemskom nivou - kosimulacija - Cadence
	9) Mogu se postici vece performanse i usteda na energiji(potrosnji)
	10) Kada dobijemo RTL mozemo da zameni virtualni model sa njim i da opet uradimo kosimulaciju, koristimo VSP da verifikujemo RTL
	
36. VSP - navesti tri pogleda i objasniti ukratko
	- Programerski pogled: VSP je mreza komponenti koje komuniciraju na nivou transakcija. Programski pogled omogucava dizajnerima softvera da imaju
	  uvid u potrebne komponente za razvoj softvera(registre), ali takodje, imaju i pregled celog sistema, mogu da zaustave izvrsavanje u proizvoljnom trenutku i
	  da ispitaju razlicite aspekte sistema(lakse se manipulise sa sistemom, recimo mozemo da ispitamo situacije sa kesom, kad je pun, kad je prazan itd)
	- Programeski pogled + vreme = U komponente unutar VSP dodajemo neku aproksimaciju vremena. Mozemo da izvrsimo analize performansi i potrosnje preciznije.
	  Rana validacija aplikacije i softvera koji zavisi od hardvera. Mesana simulacija kad budemo imali RTL blokove
	- Tacno u ciklus: imamo model kod kog je poznato tacno stanje svaki ciklus. Ovo je spor model i koristi se na kraju za finalnu verifikaciju komponenti

37. Prepreke u usvajanju bihevijalnog modelovanja, navesti razloge i ukratko objasniti svaki od njih
	- Potraznja = sistemi su bili jedno-procesorski i relativno jednostavni, pa su se timo drzali poznate RTL integracine platforme, gde se na osnovu nekog iskustva
	  odredjuju potrebni IP blokovi dok imamo, recimo postojeci procesor. Koristeci ovu metodologiju ne postoji velika mogucnost za optimizaciju. Problem je nastao kada su
	  poceli da se pojavljuju masovno viseprosorski sistemi, te metodologija vise nije bila primenljiva
	- Standardi = nisu postojlai standardizovani jezici za opis na sistemskom nivou. To je sprecavalo kompanije da kupuju sistemske opise IP blokova od
      drugih kompanija, jer nisu se uklapali sa njihovim opisima, jer nije postojao neki standard. Takodje, za postojece RTL opise IP blokova nisu postojali
	  sistemski opisi, pa su se neki odlucili da manuelno pisu sistemski opis na osnovu RTL modela, ali to je trosilo puno vremena, pa veliki broj kompanija nije
	  hteo da ulozi to vreme sve dok se nisu pojavili alati koji su taj proces automatizovali(neki od standarda su SystemC jezik, IP-XACT)
	- Automatska sinteza RTL opisa na osnovu bihevijalnog opisa = pojavljuju se sada alati koji relativno uspesno to rade, pa postaje primamljivije da se koristi 
	  ova metodologija, jer je razvoj na visem nivou apstrakcije, a samim tim i brze
	  
38. Automatska implementacija programabilnog hardvera
	- Sistemi postaju sve komplikovaniji i sve vise se implementiraju stvari u softveru
	- Jednoprocesorski sistemi ne mogu cesto da ispune postavljene zahteve - predstavljaju usko grlo (mali instruction-level paralelizam, malo resursa za paralelno izvrsavanje)
	- Multiprocesorski sistemi opste namene predstavljaju vise uskih grla koji rade u paraleli -> nije najbolje resenje za paralelizam (potrebna sinhronizacija, kasnjenje itd.)
	- Jos jedno resenje za paralelizam- koriscenje DSP procesora 
	- Takodje, pomocu EDA alata za dizajniranje procesora, moguce je praviti efikasne application-specific komponente koje u sistemu izvrsavaju "teze proracune"
	
39. Potrebi i zahtevi sistem dizajnera
	- Opste potrebe
	- Produktivnost = modeli treba da budu takvi da se mogu ponovo iskoristiti, a i ono sto fali treba lako da se kreira
	- Sta treba da nam model omoguci = HW/SW particionisanje, analizu algoritma, procenu performansi i potrosnje, selekciju IP-jeva, konfiguraciju, ...
	- Zbog slozenosti danasnjih dizajnova nije vise moguce koristiti staticke metode, pa ESL metodologija omogucava primenu dinamickih metoda, ali je potrebno napraviti model
	- Preciznost = model treba da bude precizan toliko da nam da rezultate koji odstupaju od realnih za odredjeni procenat. Sto je model slozeniji, to je i sporiji. Cesto je bolje imati
	  brze sporiji model, jer cemo pre dobiti nekakve rezultate. Za neke karakteristike nije potrebno cak ni implementirati funkcionalnost(protok na magistralama, pomocu generatora saobracaja),
	  vreme ne mora biti modelovano tacno u ciklus, jer SoC nije deterministicki ionako. Model je tu da na njemu vrsimo merenja koja su nam od interesa
	- Vreme i brzina modela
	- Cene alati = minus strana(troskovi za nabavljanje licence i integracija alata(trening inzenjera)), plus strana(brzi razvoj modela, brze se donose odredjene odluke, brze se modeli izvrsavaju, ...)
	
40. Potrebna preciznost za sistem dizajnere
	- Preziznost rezultata modela se dobija biranjem komponenti i njihovim konfigurisanjem. Dobijeni rezultati treba da budu u odredjenim okvirima
	- Preciznost se odnosi na pouzdanje koje dizajner ima u rezultate
	- Nije nuzno implementirati sve funkcionalnosti, primer za generatore saobracaja i protok
	- Efekti nekih algoritama se mogu razmotriti iako nisu napisani, ali samo ako su njihovi resursi ograniceni
	- Treba modelovati i neki aspekt vremena, ali ne skroz detaljno
	- Komponente se konfigurisu u skladu sa prosecnim opterecenjem, sem za one koje su kriticne zbog ogranicenja u relanom vremenu
	- Pored vremena danas je bitna i potrosnja, puno elektronike na baterije, a tehnologija baterija ne napreduje
	- Model je alat koji sluzi za dobijanje razlicitih merenja
	
41. Brzina i vreme za sistem dizajnere
	- Cilj ESL metodologije je da se razvoj SW zapocne pre nego sto uopste postoji HW
	- Ovo moze dovesti do toga da odredjeni delovi dizajna ne postoje dok neke imamo od ranije
	- Tada je potrebno koristiti alate koji ce da objedine sve specifikacije i ideje koje postoje za dati dizajn
	- Bolje imati sporiji model ranije, nego cekati duze na brzi
	- Jedan fora je sa generatorima saobracaja
	
42. Potrebe i zahtevi softverskog tima
	- Opsti zahtevi
	- ESL omogucava raniji razvoj SW(bolje se definise interfejs izmedju HW i SW), softverski tim koristi modele kako bi dizajnirao i debagovao HW i SW komponente sistema
	- SW je daleko slozeniji za razvoj od HW, treba obratiti paznju prilikom dizajna SW da on moze da se pokrene iako se dobije nova verzija HW
	- Preciznost modela = ne treba nam preterano precizan model, jer u ovoj fazi razvoja ni HW nije dovoljno razradjen i nemamo preterano puno info, 
	  takodje mozemo da konfigurisemo model tako da lako ispitamo neke situacije. Najbitnije za SW tim je programski pogled(registri) i odredjene info u vidu broja ciklusa i statistike kesa
	- Troskovi alata = SW alati su nesto pristupacniji zbog veceg trzista

43. Potrebna i registraska preciznost za softverski tim
	- Ako radi na modelu, radice i za prave(LAZ)
	- Model ne treba da bude preterano precizan, jer obicno u ovoj fazi HW u ranom razvoju, pa ni ne mozemo znati njegove karakteristike
	- Takodje, kod modernih SoC se frekvencija menja u zavisnoti od temperature, baterije itd. pa ni to nije konstantno
	- ESL modeli mogu da pruze neke osobine koje realna HW nema
	- Mozemo da konfigurisemo model i brzo ispitamo odredjene situacije(Ono sa kesom)
	- Najbitnije je za softverski tim da ima programerski pogled, odnosno pristup registrima kojima bi inace pristupao u realnom HW
	- Model moze da da i dodatne info u vidu aproksimativnog broja ciklusa koji je potreban da bi se odredjeni deo SW izvrsio. Ovo moze pomoci da bi se optimizovao kod.
	  Dobri modeli daju i statistiku kesa
	- Nema smisla zahtevati tacan broj ciklusa, jer su sistemi ionako nedeterministicki zbog velikog broj prekida
	
44. Performanse modela koji se izvrsava za softverski tim, klasifikacija modela na osnovu performansi
	- Performane modela se odnose na brzinu njegovog izvrsavanja
	- Cesto se misli da model treba da rade u realnom vremenu
	- Ranije dobijen model znaci vise vremena provedeno sa njim
	- Vrste
		1. Interpretirani - stand alone model
		2. Interpretirani - slave model
		3. Cache line just in time model
		4. Cache page just in time model
		5. Model koji se u potpunosti izvrsava sa host instrukcijama

45. Interpretirani samostalni modeli za softverski tim
	- Koristimo alate da generise binarni fajl i onda se instrukcije interpretiraju
	- Koristimo iste alate koje bismo koristili i za realan HW
	- Simuliramo faze zahvatanja, ucitavanja, izvrsavanja i upisivanja rezultata nazad
	- Model je jednostavan za razumeti i konstruisati
	- Jako je spor model
	- Nema aspekte strukture, odnosno protocne obrade i broja funkcionalnih jedinica(mozemo dodati, ali bude jos sporije), ne daje dovoljno tacnu procenu broja ciklusa
	- Kad se uklopi u sistem potrebno je sinhronizovati model sa ostalim komponentama
	- Model ima memorijski interfejs(deljena memorija), imamo API koji sluzi za komunikaciju sa tim modelom

46. Interpretirani slave modeli za softverski tim
	- Ovi modeli su i dalje interpretirani, ali su sada slave. Ne koriste se preko deljene memorije nego se instancioniraju kao komponenta
	- To omogucava bolju integraciju u sistemski model, recimo, napisan u SystemC-u
	- I dalje nemaju svest o vremenu, pa je potrebno voditi racuna o sinhronizaciji, spori su i dalje

47. Cache line just in time modeli za softverski tim
	- Da bismo ubrzali model moramo nekako da imamo manji broj host instrukcija po simuliranoj instrukciji
	- Cache line JIT podrazumeva da se uzmu instrukcije koje se nalaze u liniji simuliranog kesa i da se jednom kompajliraju za host,
	  nakon toga, ako su opet potrebne(a bice, jer je kes u pitanju), onda mozemo da koristimo vec translirane host instrukcije i time ustedimo na interpretaciji
	- Uzimamo instrukcije iz jedne linije, ali izmedju dve naredbe uslovong skoka(jer ne znamo gde ce se izvrsavanje dalje nastaviti)
	- Model moze da da preciznu procenu broja ciklusa
	
48. Cache page JIT modeli za softverski tim
	- Uzimamo cele stranice u kesu
	- Model je jos brzi
	- Gubimo na preciznosti, jer ne znamo tacno gde jedna instrukcija pocinje, a gde se zavrsava
	- Tri teze: Moraju se pratiti stranice u memoriji, instrukcije nisu ogranicene, nije dopustivo da se izvri cela strana, posto moze da traje beskonacno dugo

49. Modeli kompajlirani na host masini za softverski tim
	- Najbrzi su, jer nema interpretiranja instrukcija
	- Problem je sto ne mozemo da koristimo alate koji bi se koristili za realan hardver

50. Potrebe i zahtevi hardverskog tim
	- HW timu je potreban veci broj razlicitih modela sa razlicitom preciznoscu
	- Iako je danas dizaj baziran na platformi i vecina stvari se svodi na konfiguraciju i dalje postoji potreba da se napravi bar jedan novi IP
	- Najinteresantnija je verifikacija na nivou sistema, gde treba proveriti procenu protoka i performanse kako bi smo utvrdili da li su dobri semafori i tacke sinfornizacije
	- Sinhronizacija delova sistema postaje sve slozenija sa porastom broja podsistema, a time i mogucih domena takt signala
	- Zahtev je da se interfejsi komponenti standardizuju, kako bi lakse ponovo iskoristili datu komponentu
	- ESL nam daje model koji predstavlja neku osnovu za dalji razvoj HW. Taj model se ili profinjuje ili se koriste alati za automatsku sintezu(nisu savrseni)
	- Ako se ne koriste alati, onda je potrebno obratiti dosta paznje na verifikaciju
	- Verifikaciono okruzenje moze poticati i od SystemC modela(kosimulacija), to nam omogucava da verifikaciono okruzenje bude slozeno koliko i realan drajver
	- Verifikaciono okruzenje postaje programabilno i navodi IP kroz razna stanja kako bi ispitao njegovu korektnost

51. Verifikacioni zahtvei hardverskog tima
	- ESL metodologija omogucava verif i SW inzenjerima da istestiraju HW blok iz perspektive realnog softvera
	- Pored toga HW moze imati odredjene zahteve koji nisu vidljivi iz perspektive SW. Na primer ne mozemo da vidimo izlaz iz
	  LCD kontrolera, ali nam je svakako korisno da iniciramo iz SW neki ispis poznatog obrasca na displej
	- ESL omogucava automatsko generisanje, cuvanje i kontrolu sistemski testova
	- Kosimulacija = zamenjujemo neke blokove sa njihovim implementacijama i tada ostatak model postaje okruzenje, sluzi vise za detekciju nekih sistemskih problema, a ne detaljno ispitivanje
	- Koverifikacija = programski blokovi se zamenjuju sa modelima koji simuliraju odrdjene slucajeve koriscenja, ubrzava simulaciju

52. ESL tok - reprezentacija dizajna tokom razvoja, navesti nivoe i objasniti
	- ESL tok nam omoguciva da pri prelasku sa jednog nivou na drugi nivo apstrakcije(gde se povecava kompleksnot) ne izgubimo namenu dizajna
	- Product market zahtevi - zahtevi krajnjeg korisnika vezani za funkcionalnost i fizicke karakteristike uredjaja
	- Funkcionalna specifikacija - opis iz perspektive crne kutije
	- Arhitekturalni model - HW/SW particionisanje
	- Specifikacija HW i SW dizjana - opis iz perspektive prozirne kutije
	- Bihevijalni i funkcionalni modeli SW i HW - opisujemo ponasanja uz ili bez vremenskih aspekata(ako je bez, onda je cisto funkcionalan model)
	- RTL i softverski model - detaljni tajming i ponasanje
	- Model na nivou celija i embedded production software - model na nivou celija automatski sintetizujemo od RTL modela, a softver se dobija automatski od SW modela ili rucno
	- Layout - geometrijska struktura komponenti HW i njihova povezanost

53. ESL tok - cilj dizajna
	- Cilj dizajna zapocinje u glavi coveka
	- Ta info se obogacuje dodavanje novih info i na taj nacin prelazimo sa jednog na drugi nivo apstrakcije
	- Treba paziti da se prilikom prelaska ne izgubi prvobitni cilj dizajna
	- Jedno tumacenje je da se prelaskom na nizi nivo apstrakcije uklanjaju stepeni slobode
	- Tokom razvoja mi donosimo razne arhitekturalne odluke. One ne postoje samo na najvisem nivou, vec su prisutne tokom svih faza
	- Prvobitni prelazi su manuelni(specifikacija -> RTL i softver), dok su ostali polu ili skroz automatizovani
	- U buducnosti ce se automatizacija pojaviti i na visim nivoima, npr. prelaz sa bihevijlanog opisa na RTL ili cemo samo konfigurisati IP blokove ili birati koji nam trebaju

54. ESL tok - navesti korake u razvoju i objasniti moguce pristupe implementaciji koraka
	- Specifikacija i modleovanje
	- Analiza pre particionisanja
	- Particionisanje
	- Analiza posle particionisanja i debagovanje
	- Verifikacija posle particionisanja
	- Implementacija HW i SW
	- ESL podrzava top down pristup, gde idemo od najapstraktnijeg koraka(specifikacije) ka samoj implementaciji, ali ovo je idealizovano
	- Cesto se dizaj bazira na platformi gde odredjene komponente vec postoje, pa je ovo middle out dizajn
	- Ako neki IP radimo od nule, ali odmah u RTL-u bez sistemskih koraka, to predstavlja bottom up pristup

55. ESL tok - objasniti ukratko korak specifikacije i modelovanja, navesti vrste specifikacije i jezike za modelovanje koji se koriste u ovom koraku
	- Specifikacija i modelovanje - obuhvatamo opis sistema i ogranicenje i namenu proizvoda
	- Specifikacija moze biti izvrsna ili pisana prirodnim jezikom
	- Specifikacija treba da ima odredjeni nivo nedorecenosti kako bismo istinski pretrazili prostor dizajna, trebalo bi da ima sto manje implementacijskih ogranicenja
	- Ne mozemo bas imati specifikaciju bez razmatranja implementacije, jer bismo mogli da specificiramo nesto sto ne moze da se implementira
	- Treba videti da li koristimo platformu, jer to moze ozbiljno da utice na specifikaciju, pri cemu zelimo da kroz sve faze zadrzimo nedorecenost u specifikaciji
	- HW i SW se u ESL metodologiji razvijaju konkurentno
	- U idelanom svetu softver diktira sta ce se implementirati u hardveru(samo delovi SW koji su suvise zahtevni se implementiraju u HW)
	- Izvrsna specifikacija - funkcionalni i bihevijalni opis sistema koji kada se pokrene kao racunarski program ispoljava ciljano ponasanje dizajna
	- Izvrsna arhitekturalna specifikacija - sluzi nam da ispitamo razne opcije za dizajn i koncepte dizajna(crna kutija)
	- Izvrsna dizaj specifikacija - obazire se na kljucne odluke vezane za strukturu mikroarhitekture i ispoljava ponsanje sistema u smislu prozirne kutije, ali na visem nivou
	- Single sourcing, jezici(MATLAB, SystemC, System Verilog, python, ...)
	- Sve vise je prisutan razvoj na bazi modela, gde se oni profinjuju kako bismo dobili model na nizem nivou apstrakcije
	- Odlazemo detalje implementacije za sto kasnije

56. ESL tok - objasniti ukratko korak analize pre particionisanja
	- Vrsimo analize kako bismo procenili razne karakteristike sistema
	- U vremenkom domenu mozemo da ispitamo nivo paralelizma u algoritmu
	- Prostorni domen - koliko prostora je potrebno za upravljacki deo algoritma, a koliko za sam deo za obradu
	- Mozemo proceniti potrosnju. Spekulativno izvrsavanje povecava performanse, ali i potrosnju. Kesiranje moze da smanji potrosnju.
	- Domen slozenosti - vece performanse -> teza verifikacija
	- Time to market moze da ogranici sve prethodne optimizacije, ako one zahtevaju previse vremena
	- Tokom ove faze proconjuju se troskovi i priprema se za particionisanje primenom veceg broja analiza
	- Staticka analiza = formalne metode koje se koriste kada nemamo izvrsni model, a nekad se i koriste u kombinaciji sa dinamickim analizama
	- Slozenost sistema = mozemo da primenimo function point analizu(potice iz SW) da na osnovu dokumenta za specifikaciju procenimo performanse
	- Koriscenjem platforme se skracuje time to market, a time i troskovi razvoje, jer imamo vecu iskoristivost, ali se ogranicavamo u fazi particionisanja
	- Dinamicka analiza = pokretaju se simulacije i mozemo dobiti neke preciznije procene vezane za vremenske performanse(protok i kasnjenje), 
	  procenjujemo proracun, potrosnju i komunikaciju
	- Algoritamska analiza = mozemo da odradimo konverziju iz fp u fxp i procenimo preciznost i potreban broj bita
	- Izvrsni modeli su sami po sebi implementacije i imaju implementacijske artifakte
	- Akademija = previse analizira, industrija = potpuno batali(nije pravi posao)
	
57. ESL tok - objasniti ukratko korak particionisanja dizajna
	- Particionisanje je proces podele algoritma na deo koji ce se implemenitari u SW i deo koji ce se implementirati u HW(moze i SW/SW i HW/HW)
	- funkcionalana dekompozicija = specifikacija lisena implementacijskih detalja, paralelizam i ona dva nacina(jezici i alati za automatsko)
	- arhitekturalni opis i particionisanje = osnovni blokovi koji ispoljavaju ponasanja dela sistema, mapiranje(i prica o pltaformi), 
	  nacini da se mapira(sukcesivno profinjenje i eksplicitno mapiranje), razni nivou apstrakcije korisceni za opis modela
	- HW aprticionisanje = danas bazirano na platformi, sve se gura u SW, veci znaca verif SW
	- SW particionisanje = midlver, firmver, biblioteke, RTOS, ..., procesori(broj i tipovi), podela SW na procesore i njihova sinhronizacija, podela SW na jednom procesoru(algoritmi za planiranje i zamena konteksta)
	- Rekonfigurablini proracun = fleksibilan HW, azuriranje(jednom samo, mesecno, gosisnje, ...), tesko programiranje, dva nacina(kao funkcionalne jedinice za upravljacki CPU ili kao koprocesor za glavni CPU)
	- Implementacija komunikacije = template ili sinteza interfejsa(dva uslova, ono za prosecni protok i ono za FSM)

58. ESL tok - objasniti ukratko korak analize nakon particionisanja i otklanjanje gresaka

59. ESL tok - objasniti ukratko korak verifikacije nakon particionisanja
	- Verifikujemo da li je ciljno ponasanje odrzano u modelu nakon particionisanja
	- Poredimo model sa viseg nivoa apstrakcije, imamo dve verifikacije(ovu i verif implementacije)
	- Kako proveriti profinjenja? -> koraci
	- Verifikaciono planiranje, pravljenje verif okruzenja, analiza rezultata
	- Planiranje - dokument koji opisuje probleme i resenja, info o DUT-u, opis karakteristika DUT-a iz perspektive crne i prozirne kutije,
      specificira komponente verif okruzenja, model pokruvenosti
	- Ogranicenja definisu validan prostor stanja, koji se kasnije ispituje sa statickim i dinamickim metodama
	- Resenja koriste dinamicke i staticke metode i odredjuju kakve ce biti komponente verifikacionog okruzenja(ceker, pokrivenost, monitor, stimulus)
	- Obicno koristimo randomizovani ograniceni stimulus
	- Za implementaciju okruzenja koriste se HVL jezici
	- Bring up testovi i regresija
	- Otkrivanje, dijagnostika i resavanje problema
	- Pracenje progresa kroz pokrivenost(funkcionalna ili koda ili neka apstraktna)
	- Obicno koristimo randomizovani ograniceni stimulus

60. ESL tok - objasniti ukratko korak hardverske implementacije
	- HW dizajn - pisanje modela koji mogu da se sintetisu u model na nivou kapija, RTL modelovanje ili HLS
	- Ima dosta odluka koje treba doneti - protocna obrada i deljenje resursa
	- Ako se koristi sinteza treba videti da li je dobije opis u skladu sa prethodnim
	- Ekstenzibilni procesor - puno parametara koje konfigurisemo za datu namenu(npr SIMD instrukcije mozemo ukljuciti za DSP namene)
	- DSP koprocesor - optimizovani procesor za DSP primene, memorijski se mapira u adresni prostor CPU
	- VLIW koprocesori - biramo broj i tip funkcionalnih jedinica na osnovu analize algoritma(koliko operacija moze u paraleli i kog su tipa), isto je koprocesor ko DSP
	- Namesnki koprocesor - koprocesor se dizajnira za datu namenu, ima namesnki data path i control path
	- ASIC i FPGA
	- RTL flow se integrise u ESL flow
	
61. ESL tok - objasniti probleme sa bihevijalnom sintezom
	- Bihevijalna sinteza = opisuje se dizajn na visem nivou apstrakcije, te se koriste alati sa sintezu RTL modela od tog opisa
	- Treba voditi racuna o tome sta je dozvoljeno, a sta ne u HW
	- Problemi su ulazni jezik, tajming i verifikacija
	- Ulazni jezici nisu bili dobri(Verilog i VHDL)
	- Algoritmi za tajming nisu bili dobri(suvise su optimisticni)
	- Verifikacija je bila otezana zbog nepouzdanog tajminga

62. ESL tok - objasniti prednosti ESL sinteze
	- ESL sinteza ispravlja probleme bihevijalne sinteze
	- C se koristi, pretrazivanje arhitekturalnih modela sada predstavlja implementaciju sa profinjenjima u strukturi, konkurentnosti, funkcionalnim jedinicam, ...,
	  konkurentnost se postize uvodjenjem sinhronizacione interprocesorske komunikacije, sirine za podatke
	- tajming je sada bolji, kasnjenje = kasnjenje logike + kasnjenje rutiranja
	- verifikaciono okruzenje se moze ponovo koristiti, imamo modelovanje na nivou transakcija(TLM)
	- Veca produktivnost
	- Iskusan RTL inzenjer barata sa kompromisima, a dobar inzenjer ESL sinteze barata sa ogranicenjima
	- Ogranicenja su nuzna, jer je problem sinteze NP kompletan i multidimenzionalan, iammo lokalna i globalana ogranicenja
	- Mozemo ranije da ispitamo prostor dizajna
	
63. ESL tok - ukratko objasniti korak softverske implementacije
	- Softver moze da ima vise uloga
	- Ranije smo imali vodopad metodologiju gde se cekao hardver kako bi se zapoceo razvoj SW
	- SW cesto koristimo da bismo prikrili HW bagove
	- ESL metodologij zahteva da imamo veci broj modela SW koji se razvijaju zajedno sa HW i profinjuju sve dok ne dobijemo jedno jedinstveno HW/SW resenje
	- Performanse su se merile u MIPS-ima(ali ne daje pravi pogled)
	- Procenjujemo samu kompleksnos proracuna i zauzece memorije, kao i pristup memoriji
	- Jezici i alati koji se korite za implementaciju softvera slicni su onima koji se koriste za ESL razvoj SW modela(bilo tacno do 2010. sada su bas drugaciji)
	- Mozemo koristiti alate koji se zakace na pravi HW ili na virtualnu platformu
	- Kompromis izmedju brzine izvrsavanja i preciznosti modela(precizniji model se spore izvrsava), modele klasifikujemo po narednim dimenzijama: sistemski domen, domen vremenske preciznosti, izvrsa platforma, performanse za realno vreme
	- pored VP i samog HW mozemo imati FPGA HW emulator i to koristiti kao platformu za SW i radne stanice koje imaju hardverske akceleracije
	- bitna nam je preciznost u vremenskom domenu, npr bitne su situacije kad se desi prekid
	- ESL metodologija nam daje punu vidljivost sistema, pa je lakse traziti gresku, nego u samom cipu
	- Softverski model pisemo, jer cemo kasnije imati neke promene, minimalno za komunikaciju sa samim HW, ali su te promene obicno drasticnije, zato je implementacija uopste potrebna
	
	
65. ESL tok - problemi
	- HLS pravi problem verifikatorima, jer male promene u bihevijalnom opisu generisu drasticno drugaciji RTL opis, sto je problematicno za pristup prozirne kutije
	- Nemoguce je raditi samo na visem nivou apstrakcije i pouzdati se da ce alati sve uraditi korektno
	- Moguce je da ce napraviti odredjenu gresku
	- Takodje, postoje velike promene pri prelasku sa jednog nivou na drugi, pa je zato uvek potrebno zasmisljati o tome sta ce biti na nizem nivou
	- Dodaje se logika i za debug(DfT), sto dodatno unosi velike promene o kojima treba razmisljati


66. Menadžment zahteva i pisana specifikacija
	- ona tri
	- potiče iz problema i razumevanje potreba
	- model zahteva
	- menadžment zahteva, vidljivost i praćenje, praćenje kroz dizajn, baza podataka
	- 1000 individualni zahtevi
	- opis zahteva(formalni, izvrsni model, prirodni jezik)
	- teziti formalnom i izvrsnom modelu
	- ogranicenja koja unosi izvrsni model

67. ESL domeni - data flow i control flow
	- interesuje nas data path modema, elementi video obrade signala ili generalno obrade signala
	- nema nista bez control flow, ali se zanemaruje, interesantne su transformacije od ulaza do izlaza
	- staticki parametri, SNR
	- performanse algo se procenjuju u MATLABU, C, C++, beskonacni baferi
	- stanja sistema i transformacije
	- DF + CF = funkcionalnost sistema na visokom nivou, razliciti nivoi apstrakcije CF(sa i bez detalja imeplementacije arhitekture, abstrakcije vremena, osnovna stanja i modovi)
	
68. ESL domeni - protokol stek
	- podsistemi ili komunikacioni sistem koji sluze za prenos podataka kroz komunikacione kanale prateci neki skup pravila
	- hijarahijski slojevi, koristis gornji da bi podrzao gornji
	- stratum korisnicki(tok podataka kroz kanal) i kontrolni/upravljacki(kontrolne poruke)
	- embeded softver + hardver
	- fizicki sloj
	- real time zahtevi, modularna arhitektura zbog standarda, message-passing implementacije, limitirana potreba za paralelizmom
	
70. ESL domeni - embeded sistemi
	- Sta su mebeded sistemi
	- Real time zahtevi
	- Inerfejs sa okruzenjem, primer za auto
	- Nefunkcionalni zahtevi(potrosnja, real time zahtevi, resursi, dostupan softver i hardver, ...)

71. Specifikacija koja moze da se izvrsava, objasniti i nabrojati jezike za ovu specifikaciju
	- Idealni svet
	- Ona tri
		1. Automatizacija pracenja zahteva kroz proces dizajna i podsistema
		2. Poboljsanje razumevanja integracije heterogenih sistema
		3. Procesi verifikacije i implementacije se mogu poboljsati
	- Sta je izvrsna specifikacija, bihevialni opis komponenti koji ispoljava funkcije i vremenske karak ciljnog dizajna kada je to pokrenuto kao simulacija
	- Aristotel: verifikacija, u skladu sa sistemski zahtevima i ono za implementaciju
	- implementacijski artifakti
	- Bog inzenjer
	- Od pocetka do kraja, evolucija izvrsne spek
	- UML, XML, MATLAB i SystemC
	
72. Staticka analiza pre particionisanja
	- Kad nemamo izvsnu specifikaciju
	- Monotonost pre preciznosti i objasniti sa primerom
	- Vrste statickih analiza
		1. Function point analysis
		2. Analiza hardverskih ili hardverski dominantnih sistemski specifikacija
		3. ility analize
		4. Rosseta i SysML
	- Za Function point analysis
		- potice iz razvoja softvera
		- dekomponovani funkcionalni model, model podataka i bihevialni model tranzicija stanja
		- objediniti rezultate primenjenih metrika na sva tri modela u tezinskom smislu

73. Analiza pre particionisanja u slucaju koriscenja platformi
	- Reuse, troskovi, vreme razvoja, time to market
	- Neke nove funkcionalnosti se moraju implementirati
	- Vivado + Zynq je platforma
	- Naklonost prema odlukama koje su donete u vezi sa particionisanjem biranjem same platforme
	- disciplina, sve analizirati kao da krecemo od nule

74. Dinamicka anliza pre particionisanja
	- Simulacija
	- Vremensko bazirane karakteristike, arbitracioni algoritmi i planeri
	- racun(profajliranje), komunikacija(pracenje protoka podataka u odredjenim tackama), potrosnja(koliko koja instrukcija trosi energije za datu tehnologiju fabrikacije)
	- host based ececution kad nema odgovarajuci model of computation
	- monotonost pre preciznosti
	
75. Algoritamska analiza pre particionisanja
	- opterecenje izvrsavanja, proracuna, kolicina podataka koja se transportuje, greske, biti, komunikacija
	- float -> fix
	- nije nuzno, ali bolje pre nego kasnije, manje posla posle

76. Koriscenje rezultata analize pre particionisanja
	- za implementaciju i verifikaciju
	- zlatna verifikaciona okruzenja, float i fixed
	- od algo spek do softvera
    - od algo spek do hardvera
	- kosimulacija izmedju sistemske simulacije, rtl simulacije i izvrsavanja softvera na nekom ISS
	- HLS
	- vise prica nego praksa

77. Particionisanje, klasterisanje i apstrakcija, ilustrovati. Objasniti platforme u ovom kontekstu
	- Sta je particionisanje? Deljenje secifikacije na skup potencijalno konkurentnih procesa. Ona cetiri nacina
	- Svaka particija se moze opisati na ona cetiri nacina, manje ili vise apstraktan resurs
	- Nezavisnost i interfejsi i verifikacija
	- Optimizacije
	- podeli pa vladaj
	- apstrakcija i grupisanje
	- platforma je klaster, sakriva detalje razlicitih vrsta mogucih implementacija
	- aplikacija i visi nivo apstrakcije
	- deljenje troskova dizajna i fabrikacije
	- mapiranje
	- funkcionalni objekti i komunikacione linije na elemente platforme i komunikacione puteve
	- funkcije na arhitekturalne elemente, FFT -> DSP

78. Koraci pri particionisnju
	- Identifikacija funkcionalnih komponenti
	- Definisanje ciljane arhitekture, ogranicenja
	- Mapiranje funkcionalnih jedinica na arhitekturalne jedinice, ogranicenja
	- Detaljno definisanje interfejsa medju particijama, komunikacija unutra, sinteza ili manuelno
	- sve se moze automatizovati, ali sve je teze kako se ide gore

79. Funkcionalna dekompozicija pri particionisanju
	- Dva zahteva, funkcionalna reprezentacija sistema, bez implementacionih detalja, odredjeni nivo paralelizma na aplikacionom nivou da bi se iskoristila konkurentnost
	- Dva mehanizma, jezici za funkcionalnu konkurentnu izvrsnu specifikaciju, alati za automatsko izvlacenje paralelizma iz sekvencijalnog opisa(neuspesno)

80. Opis arhitekture pri particionisanju
	- Sta je arhitektura? kolekcija komponenti koje implementiraju neko ponasanje
	- jedan na jedan korespodencija
	- klase
	- apstraktni sematik
	- nije jedan na jedan u slozenim slucajevima
	- mrezni protokoli, skupovi instrukcija, arbitrazne politike
	- softverska arhitektura(organizacija taskova, slojevi, RTOS)
	- slozena specifikacija + ponovno koriscenje = platforma

81. Platforme pri particionisanju
	- Zasto platforme, time to market je BOG
	- razlicite implementacije slicnih specifikacija ili su slicni zahtevi
	- mali broj dobrih resenja
	- dizajnerska disciplina

82. Dodela pri particionisanju, navesti strategije i objasniti ih
	- Mapiranje se moze uraditi na dva nacina
	- sukcesivno prifinjenje - obratiti paznju na komunikaciju i racun
	- eksplicitno mapiranje - alati koji daju analizirane profinjene modele i daju uputsva za sintezu
	- A = Funkcionalni model bez vremena = specifikacioni model, model B = dodajemo info o arhitekturi i tajming za funkcije = skup komponenti
	- C = dodajemo prvi info za komunikaciju i vreme u kmunikaciji, to radimo odabirmo arbitra = model sa arbitrazom na magistrali
	- D = model proracuna tacan u ciklus, E = bihevijalni model sa funkcionalnom magistralom, F = RTL model
	
83. Hardversko particionisanje
	- Svodi se na konfiguraciju platforme
	- Softver je kopleksniji, opravdano je cenom alata i resenja bagova, ali ne i njihovim dijagnostikovanjem i razotkrivanjem
	- verifikacija je sada nuzna

84. Softversko particionisanje
	- Samo kriticni delovi vezani za vreme i potrosnju idu u hardver
	- Sve vise funkcija trci na nekim procesorima
	- embeded procesori
	- OS i taskovi
	- OS apstrahuje hardver
	- losa softverska arhitektura -> lose performanse sistema
	- dobra softverska arhitektura omogucava hardver dizajnerima da iscrpno istraze mogucnosti platforme

85. Softverko particionisanje na multiprocesorima i zadacima
	- Vise procesora istih ili razlicitih
	- Konkurentnost
	- Sinhronizacija i komunikacija taskova na razlicitim procesorima, namesnki komunikacioni mehanizmi
	- Podela softvera na jednom procesoru
	- Planer, promena konteksta i komunikacija

86. Softversko particionisanje u operativnim sistemima
	- Potreban je OS
	- Sta je OS
	- Alokacija memorije, implementacija komunikacije, zastita taskova
	- Uzeti u obzir OS pri softverskom particionisanju
	- Direktno mapiranje
	- Promene u OS vode do novog mapiranja
	
87. Odgovornost interfejsa i odrzavanje modela nakon particionisanja. Ilustrovati i ukratko objasniti.
	- Mogu se otkriti problemi, recimo, pri implementaciji, pa se treba vratiti nazad
	- Margina
	- Odgovornost interfejsa ostaje onom ko ga kreira
	- odrzavanje, azurirati prethodne modele

88. Objasniti sta je hardversko i softversko modelovanje i komodelovanje i nasvesti vrste
	- modeli HW i SW treba da saradjuju
	- moraju postojati kompatibilni interfejsi
	- Jedinstven model, filtriranje i transliranje(emulator), posebni(separata) modeli(prototip)

89. Hardvesko - softversko modelovanje - jedinstven model
	- nivo detalja ne mora biti velik sve dok su transakcije na interfejsnima dovoljno precizne
	- brz model na domacinu + lak debag
	- nije jasno sta je HW i sta he SW, kao i koliko detalja
	- nadleznost ostaje sistemskom inzenjeru
	- koristi se u fazi pre particionisanja, ali moze biti od koristi i posle
	- verifikacija softvera

90. Hardvesko - softversko modelovanje - filtriranje i transliranje
	- jasno definisan SW model
	- promenljiva u deljenoj memoriji
	- lakse se deli odgovornost, specificiranje aktivnosti je u nadleznosti SW inzenejera iako filter komponentu implementira hardverski tim
	- za SW na niskom nivou ili kad su poznati registri
	- poznata SW komponenta, ali HW platforma je promenljiva

91. Hardvesko - softversko modelovanje - posebni modeli
	- moze da se koristi za modelovanje na razlicitim nivoima apstrakcije(RTL model procesora, aproksimativni u ciklus modelu, tacni u ciklus modeli, modeli skupa instrukcija)
	- kada se koristi za najnizi nivo apstrakcije onda model moze biti spor zbog velikog broja detalja
	- Jasna podela olaksava dodelu odgovornosti, sistem dizajn tim je zaduzen za interfejse. Ovaj stil verifikuje specifikaciju
	- Slicno kao i filtriranje, za jedostavnije prelaze sa jednog nivoa apstrakcije na drugi treba korisititi komponente za translaciju transakcija

92. Komponente koje se koriste nakon particionisanja. Ilustrovati an primeru
	-  Da bi prelazi apstraktni model -> particionisani model bio jednostavan treba pisati modele istim stilom
	- Mix komponenti model pre i posle particionisanja -> bolje pretrazivanje prostora dizajna i otkrivanje defekata u modelima
	- Odvajanje funkcije od komunikacije
	- Profinjavanje interfejsa ili postojanje komponenti za translaciju
	- Primer

93. Dinamicka i staticka analiza nakon particionisanja. Kratko objasniti i nasvesti vrste analize
	- Sada je moguce uraditi prve znacajne analize, jer imamo particionisani model, pa mozemo videti da li treba nesto optimizovati
	- dinamicka, simulacija
	- staticka, formalne analize
	- hibridna je mix, staticka analiza podataka dobijenih dinamickim analizama, tj simulacijom, model dobije statickom analizom se dinamicki analizira
	- Vrste analiza
		1. Funkcionalna
		2. Performanse
		3. Analiza interfejsa
		4. Snage
		5. Povrsine
		6. Cene
		7. Analiza mogucnosti pronalazenja greski

94. Funkcionalna analiza nakon particionisanja
	- Vise nivoa korektnosti, imamo model blizak implementaciji
	- FIFO i keš
	- Skupljanje info o akumuliranim kasnjenjima i velicini redova cekanja i komponenata koji stvaraju ta uska grla
	- Moguca optimizacija moze dovesti do ponovnog particionisanja

95. Analiza performansi nakon particionisanja
	- Imamo particionisan model i neku sliku konkurentnosti i podele resursa
	- mogu se izvrsiti preciznije analize
	- koristimo realne podatke, jer funkcionalnost i tajming zavise od podataka
	- dinamicki generisemo podatke, a vrsimo staticke analize dobijenih povratnih info
	- usput proveravamo dok traje simulacija

96. Analiza interfejsa nakon particionisanja
	- na ovom nivou imamo apstraktne interfejse
	- dve klase, standardne magistrale i nase definisane magistrale
	- standardne ne predstavljaju problem, jer su dobro testirane
	- nove treba proveriti da li mogu da ispune zeljeni protok
	- ispravljanje u RTL-u je kasno
	- verifikovati nove interfejs komponente do najnizeg nivou apstrakcije

97. Analiza snage nakon particionisanja
	- Imamo model posle particionisanja, pratimo protok i aktivnost podataka
	- na grafikonu blezimo aktivnost dvake komponente i to povezujemo sa potrosnjom
	- ovo nije narocito precizno, ali daje neku siru sliku o potrosnji
	- gomila simulacija i iskustva
	- ukljuciti i ivicne slucajeve

98. Analiza povrsine nakon particionisanja
	- Imamo model po 500. put
	- Mozemo proceniti kompleksnot svake komponente koristeci standardne metrike
	- Ovo moze biti neprecizno bez prethodnih podataka
	- kada koristimo nove metrike, onda je dobro da uzmemo podatke iz analiza sa prethodnih projekata
	- treba analizirati uspehe i neuspehe projekata nakon sto je on zavrsen da se ne bi krenulo od nule svaki put

99. Analiza cene nakon particionisanja
	- Koriste se rezultati raznih analiza
	- Cena zavisi od toga da li se koristi platforma, koja tehnologija, koje komponente, kao i od slozenosti novih komponenti
	- Procena cene je neprecizna ako nemamo podatke iz predjasnjih projekata
	- Korstimo metrike za procenu slozenosti softvera

100. Analiza mogucosti pronalazenja greski nakon particionisanja
	- Ponasanje fabrikovanog cipa moze se osmatrati preko pinova
	- svi bagovi mogu jedino tako da se uoce
	- obicno je potrebna posebna dodatna logika koja signalizira odredjene situacije na pinovima koje se desavaju u cipu
	- cesto se o time pocne baviti tek pri kraju implementacije, sto je kasno
	- DFT treba poceti ranije u procesu razvoja
	
101. Gledista na verifikaciju
	- gledista = tipovi verifikacije koje se mogu izvrsiti(funkcionalnost, performanse, tajming, implmentacija, arhitektura)
	- Ceka se RTL nivo, nije efikasno
	- Verifikacija funkcionalnosti, verifikacija performansi, bihevijalna verifikacija, verifikacija implementacije i sistema, ali moramo imati te modle
	- ESL zeli da verif pocne sto pre
	- Imamo cosim, ali nemamo modele da ih pokrenemo
	- Opet nesto za RTL
	- Treba poceti ranije verif
	- Verif pocinje sa verif planiranjem, a zavrsava se sa analizom pokrivenosti i neuspeha

102. Verifikacioni plan
	- Verifikaciono planiranje = startegije i taktike -> verif plan
	- verif plan, dva pitanja
	- Uvod, funkcionalni i dizajn zahtevi(interfejsi i kljucne karakteristike), verif pogledi, dizajn verif okruzenja
	- Uvod = opste strategije i uvod o DUV-u
	- funckionalni zahtevi = crna kutija, dizajn zahtevi = prozirna kutija
	- verif pogledi = grupisanje vremenski i funkcionalno baziranih referenci(C++) na druge delove plana sa svojim ciljevima
	- dizajn verif okruzenja = ceker, pokrivenst, stimulus, monitor, funkcionalna specifikacija za okruzenje

103. Analiza specifikacije u verifikaciji nakon particionisanja
	- pronalazenja karakteristika i ivicnih slucajeva(kada jedan ili vise podataka ili sekvenca dogadjaja ili kombinacija dovodi do znacajne promene u ponasanju DUV-a)
	- Bottom - up(puno detalja, malo nedorecenosti), top - down(obruto)
	- Bottom - up = za male specifikacije, detaljno proucavanje, beleze se karakteristike(zahtevi ponasanja) i njihovi atributi koji pomazu da se bolje definsu karakteristike
	- karakteristike se zapisuju u odgovarajucem delu plana i njihov opis predstavlja fukcionalnu specifikaciju za model pokrivenosti
	- Top - down = onaj tim se oformaljava

104. Dizajn modela pokrivenosti na visokom nivou
	- Model pokrivenosti je aproksimacija opisa ponasanja dela dizajna SW i HW. Cilj je kvantifikacija regija ponasanja DUV-a kako bismo otkrili sta je ispitano
	- velicina i tacnost modela
	- opis semantike, par recenica, fukcionalna specifikacija
	- atributi, vrednosti(fizicki prostor i validni prostor), vremene odabiranja i korelaciono vreme
	- odnosi medju atrubutima, matrica, hijerarhija i hibridni model

105. Detaljan dizajn modela pokrivenosti
	- mapiranje dizajna top level modela na verif okruzenje
	- sta(registar, signal ili promenljiva), gde(arhitekturalni element okruzenja koji ce biti zaduzen za odabiranje), kada(vremena korelacije i odabiranja)

106. Hibridne metrike modela pokrivenosti
	- metrike poticu iz vise izvora
	- implicine, eksplicitne
	- podaci, vreme
	- implementacija, specifikacija
	- iz simulacije ili formalne analize

107. Resenje verifikacionog problema
	- kombinacija formalnih i dinamickih metoda
	- staticke metode dokazuju teoreme i mogu da pokazu potpuno odsustvo bagova
	- dinamicke se baziraju na simulaciji gde se generise stimulus
	- zbog kompleksnosti modela posle particionisanja na nivou transakcija se koriste uglavnom dinamicke metode
	- verif IP-jevi

108. Stimulus generatori u verifikaciji nakon particionisanja
	- koristi se randomizovano ograniceno generisanje stimulusa
	- ogranicenja dobijamo od funkcionalnih zahteva, posebno belezimo i ogranicenja koja dovode do generisanja stimulusa koji inicira ivicne slucajeva
	- hocemo automatizovano verif okruzenje
	- isplati se, jer se poveca produktivnost
	- automatizuje se i povratna sprega izmedju merenja pokrivenosti i generisanja stimulusa
	- Bring - up testovi

109. Čeker komponente u verifikaciji nakon particionisanja
	- Čeker nam treba da proverimor rezultate
	- Referentni model
	- Skorbord - skladisiti ocekivane rezultatae ili mu se prosledjuje ulazni stimulus, pa on vrsi transformacije
	- Provere distribuiranih podataka i vremana = proceduralni kod, konkurentne ili neposredne tvrdnje. Živost, bezbednost i pravednost. Blizi su izvoru baga